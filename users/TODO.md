# âœ”ï¸TODO

**Planned features**:
1. Implement Scheme - We have two simple Haskell version. We need it for next steps. Use MegaParsec
2. Implement Asm for Combinators:
   1. Implement Lazier - Schema DSL. 
   2. Implement Scheme Like Lazier (SLC)  - For all functional language
   3. Implement MLC - For all functional languagee
3. Implement other Eso-Schemes:
   1. Compile Unlambda-Scheme to Unlambda. It is a litle dynamic. Scheme has 4 types
   2. Compile Funge-Scheme to Funge. It is hard because code is in CL. It is a litle dynamic. Scheme has 2 types
   3. Compile Malbolge-Scheme to Malbolge. It is hard because code is in APL
4. Compile Scheme to:
   1. WASM
   2. SICP-Asm
   3. ELVM
5. Compile ELVM to WASM and SICP-Asm
6. Compile WASM and SICP-Asm to MCL
7. Implement imperative assemblers
   1. Piet-Ams, 
   2. Malbolge-Asm. These are many Malbolge-Asm, but all in C
   3. Funge-Asm
   4. Beatnik-Ams
   5. HaPyLi
8. Implement languages
   1. Piet. It is hard because IO
   2. Implement Malbolge - We have Haskell version. We have to do it because it is simple
   3. Beatnik
   4. Funge
   5. False
9. Compile C - It is the last goal
  1. C2WS
  2. C2BF
   
You can propose feature by [GitHub](https://github.com/helvm/helvm.github.io/issues).
But if there is a reference code ih Haskell, the feature goes up

For more see [ROADMAP](../developers/ROADMAP.md).

# ğŸ¦„ ğŸŒˆ â¤ï¸ ğŸ’› ğŸ’š ğŸ’™ ğŸ¤ ğŸ–¤
