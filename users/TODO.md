# âœ”ï¸TODO

**Planned features**:
1. HELPS - Implement Haskell in Haskell
2. HELMS - Implement Scheme -
   1. We have two simple Haskell version. We need it for next steps. Use MegaParsec
   2. Implement other Eso-Schemes:
      1. Compile Unlambda-Scheme to Unlambda. It is a litle dynamic. Scheme has 4 types
      2. Compile Funge-Scheme to Funge. It is hard because code is in CL. It is a litle dynamic. Scheme has 2 types
      3. Compile Malbolge-Scheme to Malbolge. It is hard because code is in APL
   3. Compile Scheme to:
      1. WASM
      2. SICP-Asm
      3. ELVM
3. HELTC - Implement Asm for Combinators:
   1. Implement Lazier - Schema DSL. 
   2. Implement Scheme Like Lazier (SLC)  - For all functional language
   3. Implement MLC - For all functional languagee
4. HELCT - Compile C - It is the last goal
    1. C2WS
    2. C2BF
5. HELPA 
   1. Implement imperative assemblers
      1. Piet-Ams, 
      2. Malbolge-Asm. These are many Malbolge-Asm, but all in C
      3. Funge-Asm
      4. Beatnik-Ams
      5. HaPyLi
   2. Other:
      1. Compile ELVM to WASM and SICP-Asm
      2. Compile WASM and SICP-Asm to MCL
6. HELMA - Implement languages
   1. Piet. It is hard because IO
   2. Implement Malbolge - We have Haskell version. We have to do it because it is simple
   3. Beatnik
   4. Funge
   5. False
   
You can propose feature by [GitHub](https://github.com/helvm/helvm.github.io/issues).
But if there is a reference code ih Haskell, the feature goes up

For more see [ROADMAP](../developers/ROADMAP.md).

# ğŸ¦„ ğŸŒˆ â¤ï¸ ğŸ’› ğŸ’š ğŸ’™ ğŸ¤ ğŸ–¤
